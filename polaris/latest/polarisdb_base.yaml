apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    environment: ${ENVIRONMENT_NAME}
  name: polaris-manage-secrets
  namespace: ${NAMESPACE}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    helm.sh/hook: pre-upgrade,pre-install
    helm.sh/hook-delete-policy: before-hook-creation
    helm.sh/hook-weight: "0"
  labels:
    chartVersion: 0.0.790
    component: swip-db
    componentVersion: 0.0.790
    environment: ${ENVIRONMENT_NAME}
    service: vault-init
  name: vault-init
  namespace: ${NAMESPACE}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    environment: ${ENVIRONMENT_NAME}
  name: polaris-manage-secrets
  namespace: ${NAMESPACE}
rules:
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - create
  - update
  - patch
  - delete
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  annotations:
    helm.sh/hook: pre-upgrade,pre-install
    helm.sh/hook-delete-policy: before-hook-creation
    helm.sh/hook-weight: "0"
  labels:
    chartVersion: 0.0.790
    component: swip-db
    componentVersion: 0.0.790
    environment: ${ENVIRONMENT_NAME}
    service: vault-init
  name: vault-init
  namespace: ${NAMESPACE}
rules:
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - create
  - update
  - patch
  - delete
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    environment: ${ENVIRONMENT_NAME}
  name: polaris-manage-secrets
  namespace: ${NAMESPACE}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: polaris-manage-secrets
subjects:
- kind: ServiceAccount
  name: polaris-manage-secrets
  namespace: ${NAMESPACE}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  annotations:
    helm.sh/hook: pre-upgrade,pre-install
    helm.sh/hook-delete-policy: before-hook-creation
    helm.sh/hook-weight: "1"
  labels:
    chartVersion: 0.0.790
    component: swip-db
    componentVersion: 0.0.790
    environment: ${ENVIRONMENT_NAME}
    service: vault-init
  name: vault-init
  namespace: ${NAMESPACE}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-init
subjects:
- kind: ServiceAccount
  name: vault-init
  namespace: ${NAMESPACE}
---
apiVersion: v1
data:
  config.json: |
    {"listener":{"tcp":{"address":"[::]:8200","cluster_address":"[::]:8201","tls_cert_file":"/vault/tls/tls.crt","tls_cipher_suites":"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_256_GCM_SHA384,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA","tls_disable":false,"tls_key_file":"/vault/tls/tls.key","tls_prefer_server_cipher_suites":true}},"storage":{"consul":{"address":"polaris-db-consul:8500","path":"vault"}},"ui":true}
kind: ConfigMap
metadata:
  labels:
    app: polaris-db-vault
    environment: ${ENVIRONMENT_NAME}
    release: swip-db
  name: polaris-db-vault-config
  namespace: ${NAMESPACE}
---
apiVersion: v1
data:
  init.sh: |-
    #!/bin/bash
    set -e
    if [[ -z "$POSTGRES_HOST" ]]; then
      echo "POSTGRES_HOST must be set"
      exit 1
    fi

    echo "Creating databases if not exists..."
    PGPASSWORD=${POSTGRESQL_PASSWORD} psql -h $POSTGRES_HOST -U $POSTGRESQL_USER -d postgres << EOF
    SELECT 'CREATE DATABASE "cos"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'cos')\gexec
    SELECT 'CREATE DATABASE "jobs-service"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'jobs-service')\gexec
    SELECT 'CREATE DATABASE "issues"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'issues')\gexec
    SELECT 'CREATE DATABASE "code_analysis"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'code_analysis')\gexec
    SELECT 'CREATE DATABASE "tds_fuzz"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'tds_fuzz')\gexec
    SELECT 'CREATE DATABASE "configs"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'configs')\gexec
    SELECT 'CREATE DATABASE "triage_query"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'triage_query')\gexec
    SELECT 'CREATE DATABASE "triage_command"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'triage_command')\gexec
    SELECT 'CREATE DATABASE "desktop_metrics"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'desktop_metrics')\gexec
    SELECT 'CREATE DATABASE "tds_csv"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'tds_csv')\gexec
    SELECT 'CREATE DATABASE "tds_seeker"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'tds_seeker')\gexec
    SELECT 'CREATE DATABASE "tds_sca"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'tds_sca')\gexec
    SELECT 'CREATE DATABASE "rp-issue-manager"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'rp-issue-manager')\gexec
    SELECT 'CREATE DATABASE "rp-portfolio"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'rp-portfolio')\gexec
    SELECT 'CREATE DATABASE "rp-report"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'rp-report')\gexec
    SELECT 'CREATE DATABASE "rp-tools-portfolio"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'rp-tools-portfolio')\gexec
    SELECT 'CREATE DATABASE "notifications"' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'notifications')\gexec
    EOF
kind: ConfigMap
metadata:
  labels:
    environment: ${ENVIRONMENT_NAME}
    name: polaris-postgres-init-config
  name: polaris-postgres-init-config
  namespace: ${NAMESPACE}
---
apiVersion: v1
data:
  host: ${SMTP_HOST}
  port: ${SMTP_PORT}
kind: ConfigMap
metadata:
  labels:
    environment: ${ENVIRONMENT_NAME}
  name: polaris-smtp
  namespace: ${NAMESPACE}
---
apiVersion: v1
data:
  POSTGRES_SSL_MODE: ${POSTGRES_SSL_MODE}
  POSTGRESQL_HOST: ${POSTGRES_HOST}
  POSTGRESQL_PORT: ${POSTGRES_PORT}
kind: ConfigMap
metadata:
  labels:
    environment: ${ENVIRONMENT_NAME}
  name: postgresql-config
  namespace: ${NAMESPACE}
---
apiVersion: v1
data:
  auth-client.hcl: |-
    path "secret/data/auth/public/*" {
      capabilities = ["list", "read"]
    }
    path "secret/metadata/auth/public/*" {
      capabilities = ["list", "read"]
    }
    path "secret/data/migratorLog" {
      capabilities = ["list", "read"]
    }
  auth-server.hcl: |-
    path "secret/metadata/auth/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }
    path "secret/destroy/auth/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }
    path "secret/data/auth/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }
    path "secret/delete/auth/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }
    path "secret/undelete/auth/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }
    path "secret/data/migratorLog" {
      capabilities = ["list", "read"]
    }
  tds-code-analysis.hcl: |-
    path "secret/data/auth/public/*" {
      capabilities = ["list", "read"]
    }
    path "secret/data/migratorLog" {
      capabilities = ["list", "read"]
    }
    path "secret/data/codeanalysis/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }
    path "secret/metadata/auth/public/*" {
      capabilities = ["list", "read"]
    }
  vault-migrator.hcl: |-
    path "secret/metadata/*" {
      capabilities = ["create", "read", "update", "list"]
    }
    path "secret/data/*" {
      capabilities = ["create", "read", "update", "list"]
    }
kind: ConfigMap
metadata:
  labels:
    chartVersion: 0.0.790
    component: swip-db
    componentVersion: 0.0.790
    environment: ${ENVIRONMENT_NAME}
    service: vault-init
  name: vault-policies
  namespace: ${NAMESPACE}
---
apiVersion: v1
data:
  gossip-key: SXErN2o1QVo0cm1ocXFNbG1OLzFCdz09
kind: Secret
metadata:
  labels:
    component: swip-db-consul
    environment: ${ENVIRONMENT_NAME}
    release: swip-db
  name: polaris-db-consul-gossip-key
  namespace: ${NAMESPACE}
type: Opaque
---
apiVersion: v1
data:
  passwd: ${SMTP_PASSWORD}
  username: ${SMTP_USERNAME}
kind: Secret
metadata:
  labels:
    environment: ${ENVIRONMENT_NAME}
  name: polaris-smtp
  namespace: ${NAMESPACE}
type: Opaque
---
apiVersion: v1
data:
  POSTGRESQL_ADMIN_PASSWORD: ${POSTGRES_PASSWORD}
  POSTGRESQL_DATABASE: ${POSTGRES_USERNAME}
  POSTGRESQL_PASSWORD: ${POSTGRES_PASSWORD}
  POSTGRESQL_USER: ${POSTGRES_USERNAME}
kind: Secret
metadata:
  labels:
    app: postgresql
    environment: ${ENVIRONMENT_NAME}
  name: postgresql-config
  namespace: ${NAMESPACE}
type: Opaque
---
apiVersion: v1
kind: Service
metadata:
  annotations:
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
  labels:
    component: swip-db-consul
    environment: ${ENVIRONMENT_NAME}
    release: swip-db
  name: polaris-db-consul
  namespace: ${NAMESPACE}
spec:
  clusterIP: None
  ports:
  - name: http
    port: 8500
  - name: rpc
    port: 8400
  - name: serflan-tcp
    port: 8301
    protocol: TCP
  - name: serflan-udp
    port: 8301
    protocol: UDP
  - name: serfwan-tcp
    port: 8302
    protocol: TCP
  - name: serfwan-udp
    port: 8302
    protocol: UDP
  - name: server
    port: 8300
  - name: consuldns-tcp
    port: 8600
  - name: consuldns-udp
    port: 8600
    protocol: UDP
  selector:
    component: swip-db-consul
    environment: ${ENVIRONMENT_NAME}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    component: swip-db-consul
    environment: ${ENVIRONMENT_NAME}
    release: swip-db
  name: polaris-db-consul-ui
  namespace: ${NAMESPACE}
spec:
  ports:
  - name: http
    port: 8500
  selector:
    component: swip-db-consul
    environment: ${ENVIRONMENT_NAME}
  type: NodePort
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: polaris-db-vault
    environment: ${ENVIRONMENT_NAME}
    release: swip-db
  name: polaris-db-vault
  namespace: ${NAMESPACE}
spec:
  ports:
  - name: api
    port: 8200
    protocol: TCP
    targetPort: 8200
  selector:
    app: polaris-db-vault
    environment: ${ENVIRONMENT_NAME}
    release: swip-db
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  labels:
    chartVersion: 0.0.790
    component: swip-db
    componentVersion: 0.0.790
    environment: ${ENVIRONMENT_NAME}
    service: vault-exporter
  name: vault-exporter
  namespace: ${NAMESPACE}
spec:
  ports:
  - name: http
    port: 9410
  selector:
    app: vault
    environment: ${ENVIRONMENT_NAME}
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    helm.sh/hook: pre-upgrade,pre-install
    helm.sh/hook-delete-policy: before-hook-creation
    helm.sh/hook-weight: "3"
  labels:
    chartVersion: 0.0.790
    component: swip-db
    componentVersion: 0.0.790
    environment: ${ENVIRONMENT_NAME}
    service: vault-init
  name: vault-init
  namespace: ${NAMESPACE}
spec:
  selector:
    matchLabels:
      environment: ${ENVIRONMENT_NAME}
      service: vault-init
  template:
    metadata:
      labels:
        chart: swip-db
        chartVersion: 0.0.790
        component: swip-db
        componentVersion: 0.0.790
        environment: ${ENVIRONMENT_NAME}
        service: vault-init
      name: vault-init
    spec:
      containers:
      - command:
        - vault-init
        env:
        - name: VAULT_ADDR
          value: https://polaris-db-vault:8200
        - name: VAULT_CACERT
          value: /vault/tls/ca.crt
        - name: VAULT_INIT_SECRET
          value: vault-init-secret
        - name: VAULT_SECRET_ENGINE_VERSION
          value: v2
        - name: VAULT_KUBERNETES_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: VAULT_POLICY_CONFIGS
          value: /vault/policies
        - name: AUTH_SERVER_VAULT_CLIENT_CERTIFICATE
          value: /auth-server-tls-certificate/tls.crt
        - name: AUTH_CLIENT_VAULT_CLIENT_CERTIFICATE
          value: /auth-client-tls-certificate/tls.crt
        - name: TDS_CODE_ANALYSIS_VAULT_CLIENT_CERTIFICATE
          value: /tds-code-analysis-tls-certificate/tls.crt
        - name: VAULT_MIGRATOR_VAULT_CLIENT_CERTIFICATE
          value: /vault-migrator-tls-certificate/tls.crt
        - name: KUBERNETES_LABELS
          value: |-
            environment: "${ENVIRONMENT_NAME}"
            service: "vault-init"
            component: "swip-db"
            componentVersion: "0.0.790"
            chart: "swip-db"
            chartVersion: "0.0.790"
        image: gcr.io/snps-swip-staging/vault-util:0.1.13
        imagePullPolicy: IfNotPresent
        name: vault-init
        volumeMounts:
        - mountPath: /vault/tls
          name: vault-tls-certificate
        - mountPath: /auth-server-tls-certificate
          name: auth-server-tls-certificate
        - mountPath: /auth-client-tls-certificate
          name: auth-client-tls-certificate
        - mountPath: /tds-code-analysis-tls-certificate
          name: tds-code-analysis-tls-certificate
        - mountPath: /vault-migrator-tls-certificate
          name: vault-migrator-tls-certificate
        - mountPath: /vault/policies
          name: vault-policy-configs
      imagePullSecrets:
      - name: ${IMAGE_PULL_SECRETS}
      restartPolicy: Always
      securityContext:
        runAsNonRoot: true
        runAsUser: 5000
      serviceAccount: vault-init
      volumes:
      - name: vault-tls-certificate
        secret:
          secretName: vault-tls-certificate
      - configMap:
          name: vault-policies
        name: vault-policy-configs
      - name: auth-server-tls-certificate
        secret:
          secretName: auth-server-tls-certificate
      - name: auth-client-tls-certificate
        secret:
          secretName: auth-client-tls-certificate
      - name: tds-code-analysis-tls-certificate
        secret:
          secretName: tds-code-analysis-tls-certificate
      - name: vault-migrator-tls-certificate
        secret:
          secretName: vault-migrator-tls-certificate
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  annotations: {}
  labels:
    app: polaris-db-vault
    environment: ${ENVIRONMENT_NAME}
    release: swip-db
  name: polaris-db-vault
  namespace: ${NAMESPACE}
spec:
  replicas: 1
  selector:
    matchLabels:
      environment: ${ENVIRONMENT_NAME}
  strategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      annotations:
        cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
      labels:
        app: polaris-db-vault
        environment: ${ENVIRONMENT_NAME}
        release: swip-db
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  app: polaris-db-vault
                  release: swip-db
              topologyKey: kubernetes.io/hostname
            weight: 100
      containers:
      - command:
        - vault
        - server
        - -config
        - /vault/config/config.json
        env:
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: VAULT_CLUSTER_ADDR
          value: https://$(POD_IP):8201
        - name: VAULT_LOG_LEVEL
          value: info
        - name: VAULT_CACERT
          value: /vault/tls/ca.crt
        image: vault:0.11.2
        imagePullPolicy: IfNotPresent
        livenessProbe:
          tcpSocket:
            port: 8200
        name: vault
        ports:
        - containerPort: 8200
          name: api
        - containerPort: 8201
          name: cluster-address
        readinessProbe:
          httpGet:
            path: /v1/sys/health?standbycode=204&uninitcode=204&
            port: 8200
            scheme: HTTPS
        securityContext:
          capabilities:
            add:
            - IPC_LOCK
          readOnlyRootFilesystem: true
        volumeMounts:
        - mountPath: /vault/config/
          name: vault-config
        - mountPath: /root/
          name: vault-root
        - mountPath: /vault/tls
          name: vault-tls-certificate
      - command:
        - vault-sidecar
        - /vault/init
        env:
        - name: VAULT_ADDR
          value: https://localhost:8200
        - name: VAULT_CACERT
          value: /vault/tls/ca.crt
        image: gcr.io/snps-swip-staging/vault-util:0.1.13
        name: vault-sidecar
        volumeMounts:
        - mountPath: /vault/tls
          name: vault-tls-certificate
        - mountPath: /vault/init
          name: vault-init-secret
      - env:
        - name: VAULT_ADDR
          value: https://127.0.0.1:8200
        - name: VAULT_CACERT
          value: /vault/tls/ca.crt
        image: gcr.io/snps-swip-staging/public/grapeshot/vault_exporter:v0.1.2
        imagePullPolicy: IfNotPresent
        name: vault-exporter
        ports:
        - containerPort: 9410
          name: cluster-address
          protocol: TCP
        resources:
          limits:
            cpu: 200m
            memory: 384Mi
          requests:
            cpu: 100m
            memory: 200Mi
        securityContext:
          procMount: Default
          readOnlyRootFilesystem: true
        volumeMounts:
        - mountPath: /vault/tls
          name: vault-tls-certificate
      imagePullSecrets:
      - name: ${IMAGE_PULL_SECRETS}
      initContainers:
      - args:
        - --http-readiness-check-urls=http://polaris-db-consul-0.polaris-db-consul.$(POD_NAMESPACE).svc.cluster.local:8500
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        image: gcr.io/snps-swip-staging/polaris-init:1.0.0
        imagePullPolicy: Always
        name: polaris-init
      volumes:
      - configMap:
          name: polaris-db-vault-config
        name: vault-config
      - emptyDir: {}
        name: vault-root
      - name: vault-tls-certificate
        secret:
          secretName: vault-tls-certificate
      - name: vault-init-secret
        secret:
          secretName: vault-init-secret
---
apiVersion: apps/v1beta1
kind: StatefulSet
metadata:
  labels:
    component: swip-db-consul
    environment: ${ENVIRONMENT_NAME}
    release: swip-db
  name: polaris-db-consul
  namespace: ${NAMESPACE}
spec:
  replicas: 1
  selector:
    matchLabels:
      component: swip-db-consul
      environment: ${ENVIRONMENT_NAME}
      release: swip-db
  serviceName: polaris-db-consul
  template:
    metadata:
      labels:
        chart: consul-3.4.2
        component: swip-db-consul
        environment: ${ENVIRONMENT_NAME}
        heritage: Tiller
        release: swip-db
      name: polaris-db-consul
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: component
                  operator: In
                  values:
                  - swip-db-consul
              topologyKey: kubernetes.io/hostname
            weight: 1
      containers:
      - command:
        - /bin/sh
        - -ec
        - |
          IP=$(hostname -i)
          if [ -e /etc/consul/secrets/gossip-key ]; then
            echo "{\"encrypt\": \"$(base64 /etc/consul/secrets/gossip-key)\"}" > /etc/consul/encrypt.json
            GOSSIP_KEY="-config-file /etc/consul/encrypt.json"
          fi

          for i in $(seq 0 $((${INITIAL_CLUSTER_SIZE} - 1))); do
              while true; do
                  echo "Waiting for ${STATEFULSET_NAME}-${i}.${STATEFULSET_NAME} to come up"
                  ping -W 1 -c 1 ${STATEFULSET_NAME}-${i}.${STATEFULSET_NAME}.${STATEFULSET_NAMESPACE}.svc > /dev/null && break
                  sleep 1s
              done
          done

          PEERS=""
          for i in $(seq 0 $((${INITIAL_CLUSTER_SIZE} - 1))); do
            NEXT_PEER="$(ping -c 1 ${STATEFULSET_NAME}-${i}.${STATEFULSET_NAME}.${STATEFULSET_NAMESPACE}.svc | awk -F'[()]' '/PING/{print $2}')"
            if [ "${NEXT_PEER}" != "${POD_IP}" ]; then
              PEERS="${PEERS}${PEERS:+ } -retry-join ${STATEFULSET_NAME}-${i}.${STATEFULSET_NAME}.${STATEFULSET_NAMESPACE}.svc"
            fi
          done

          exec /bin/consul agent \
            -ui \
            -domain=consul \
            -data-dir=/var/lib/consul \
            -server \
            -bootstrap-expect=${INITIAL_CLUSTER_SIZE} \
            -disable-keyring-file \
            -bind=0.0.0.0 \
            -advertise=${IP} \
            ${PEERS} \
            ${GOSSIP_KEY} \
            -client=0.0.0.0 \
            -dns-port=${DNSPORT} \
            -http-port=8500
        env:
        - name: INITIAL_CLUSTER_SIZE
          value: "1"
        - name: STATEFULSET_NAME
          value: polaris-db-consul
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: STATEFULSET_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: DNSPORT
          value: "8600"
        image: consul:1.0.0
        imagePullPolicy: Always
        livenessProbe:
          exec:
            command:
            - consul
            - members
          initialDelaySeconds: 300
          timeoutSeconds: 5
        name: polaris-db-consul
        ports:
        - containerPort: 8500
          name: http
        - containerPort: 8400
          name: rpc
        - containerPort: 8301
          name: serflan-tcp
          protocol: TCP
        - containerPort: 8301
          name: serflan-udp
          protocol: UDP
        - containerPort: 8302
          name: serfwan-tcp
          protocol: TCP
        - containerPort: 8302
          name: serfwan-udp
          protocol: UDP
        - containerPort: 8300
          name: server
        - containerPort: 8600
          name: consuldns-tcp
        - containerPort: 8600
          name: consuldns-udp
          protocol: UDP
        resources: {}
        volumeMounts:
        - mountPath: /var/lib/consul
          name: datadir
        - mountPath: /etc/consul/secrets
          name: gossip-key
          readOnly: true
      securityContext:
        fsGroup: 1000
      volumes:
      - name: gossip-key
        secret:
          secretName: polaris-db-consul-gossip-key
  updateStrategy:
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      labels:
        component: swip-db-consul
        environment: ${ENVIRONMENT_NAME}
        release: swip-db
      name: datadir
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 1Gi
---
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  labels:
    component: swip-db-consul
    environment: ${ENVIRONMENT_NAME}
    release: swip-db
  name: polaris-db-consul-pdb
  namespace: ${NAMESPACE}
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      component: swip-db-consul
      environment: ${ENVIRONMENT_NAME}
---
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  labels:
    environment: ${ENVIRONMENT_NAME}
  name: polaris-db-vault
  namespace: ${NAMESPACE}
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app: polaris-db-vault
      environment: ${ENVIRONMENT_NAME}
      release: swip-db
---
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    environment: ${ENVIRONMENT_NAME}
    name: polaris-init-postgres
  name: polaris-init-postgres
  namespace: ${NAMESPACE}
spec:
  backoffLimit: 4
  template:
    metadata:
      labels:
        environment: ${ENVIRONMENT_NAME}
    spec:
      containers:
      - args:
        - -c
        - sleep 60; /tmp/postgres-init/init.sh
        command:
        - /bin/bash
        env:
        - name: POSTGRES_HOST
          valueFrom:
            configMapKeyRef:
              key: POSTGRESQL_HOST
              name: postgresql-config
        - name: POSTGRES_PORT
          valueFrom:
            configMapKeyRef:
              key: POSTGRESQL_PORT
              name: postgresql-config
        - name: POSTGRESQL_USER
          valueFrom:
            secretKeyRef:
              key: POSTGRESQL_USER
              name: postgresql-config
        - name: POSTGRESQL_PASSWORD
          valueFrom:
            secretKeyRef:
              key: POSTGRESQL_PASSWORD
              name: postgresql-config
        - name: POSTGRES_TYPE
          value: ${POSTGRES_TYPE}
        image: registry.access.redhat.com/rhscl/postgresql-96-rhel7:1
        name: postgres-init
        volumeMounts:
        - mountPath: /tmp/postgres-init
          name: postgres-init
      imagePullSecrets:
      - name: ${IMAGE_PULL_SECRETS}
      initContainers:
      - args:
        - --postgres-database=postgres
        - --postgres-host=$(POSTGRES_HOST)
        - --postgres-password=$(POSTGRESQL_PASSWORD)
        - --postgres-port=$(POSTGRES_PORT)
        - --postgres-user=$(POSTGRESQL_USER)
        env:
        - name: POSTGRES_HOST
          valueFrom:
            configMapKeyRef:
              key: POSTGRESQL_HOST
              name: postgresql-config
        - name: POSTGRES_PORT
          valueFrom:
            configMapKeyRef:
              key: POSTGRESQL_PORT
              name: postgresql-config
        - name: POSTGRESQL_USER
          valueFrom:
            secretKeyRef:
              key: POSTGRESQL_USER
              name: postgresql-config
        - name: POSTGRESQL_PASSWORD
          valueFrom:
            secretKeyRef:
              key: POSTGRESQL_PASSWORD
              name: postgresql-config
        image: gcr.io/snps-swip-staging/polaris-init:1.0.0
        imagePullPolicy: Always
        name: polaris-init
      restartPolicy: Never
      volumes:
      - configMap:
          defaultMode: 511
          name: polaris-postgres-init-config
        name: postgres-init
---
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    environment: ${ENVIRONMENT_NAME}
    service: tools-minio-secret-init
  name: tools-minio-secret-init
  namespace: ${NAMESPACE}
spec:
  template:
    metadata:
      labels:
        environment: ${ENVIRONMENT_NAME}
        service: tools-minio-secret-init
      name: tools-minio-secret-init
    spec:
      containers:
      - command:
        - minio-init
        env:
        - name: MINIO_KUBERNETES_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: MINIO_SECRET_NAME
          value: swip-tools-minio
        - name: KUBERNETES_LABELS
          value: |-
            environment: "${ENVIRONMENT_NAME}"
            service: "tools-minio-secret-init"
            component: "swip-db"
            componentVersion: "0.0.760"
            chart: "swip-db"
            chartVersion: "0.0.760"
        image: gcr.io/snps-swip-staging/minio-util:0.0.9
        imagePullPolicy: IfNotPresent
        name: tools-minio-secret-init
      imagePullSecrets:
      - name: ${IMAGE_PULL_SECRETS}
      restartPolicy: OnFailure
      serviceAccount: polaris-manage-secrets
---
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    environment: ${ENVIRONMENT_NAME}
    service: upload-server-secret-init
  name: upload-server-secret-init
  namespace: ${NAMESPACE}
spec:
  template:
    metadata:
      labels:
        environment: ${ENVIRONMENT_NAME}
        service: upload-server-secret-init
      name: upload-server-secret-init
    spec:
      containers:
      - command:
        - minio-init
        env:
        - name: MINIO_KUBERNETES_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: MINIO_SECRET_NAME
          value: swip-upload-server
        - name: KUBERNETES_LABELS
          value: |-
            environment: "${ENVIRONMENT_NAME}"
            service: "upload-server-secret-init"
            component: "swip-db"
            componentVersion: "0.0.760"
            chart: "swip-db"
            chartVersion: "0.0.760"
        image: gcr.io/snps-swip-staging/minio-util:0.0.9
        imagePullPolicy: IfNotPresent
        name: upload-server-secret-init
      imagePullSecrets:
      - name: ${IMAGE_PULL_SECRETS}
      restartPolicy: OnFailure
      serviceAccount: polaris-manage-secrets
---
apiVersion: batch/v1
kind: Job
metadata:
  annotations:
    helm.sh/hook: pre-upgrade,pre-install
    helm.sh/hook-delete-policy: hook-succeeded,before-hook-creation
    helm.sh/hook-weight: "2"
  labels:
    chartVersion: 0.0.790
    component: swip-db
    componentVersion: 0.0.790
    environment: ${ENVIRONMENT_NAME}
    service: vault-init
  name: vault-tls-init
  namespace: ${NAMESPACE}
spec:
  template:
    metadata:
      labels:
        chart: swip-db
        chartVersion: 0.0.790
        component: swip-db
        componentVersion: 0.0.790
        environment: ${ENVIRONMENT_NAME}
        service: vault-init
      name: vault-tls-init
    spec:
      containers:
      - command:
        - vault-tls-init
        env:
        - name: VAULT_SERVICE_NAME
          value: polaris-db-vault
        - name: VAULT_KUBERNETES_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: VAULT_CLIENT_CERTIFICATES
          value: auth-server,auth-client,tds-code-analysis,vault-migrator
        - name: KUBERNETES_LABELS
          value: |-
            environment: "${ENVIRONMENT_NAME}"
            service: "vault-init"
            component: "swip-db"
            componentVersion: "0.0.790"
            chart: "swip-db"
            chartVersion: "0.0.790"
        image: gcr.io/snps-swip-staging/vault-util:0.1.13
        imagePullPolicy: IfNotPresent
        name: vault-tls-init
      imagePullSecrets:
      - name: ${IMAGE_PULL_SECRETS}
      restartPolicy: OnFailure
      serviceAccount: vault-init
---
apiVersion: v1
data:
  entrypoint.js: |-
    db.adminCommand({setFeatureCompatibilityVersion: "4.0"});
    print("=====Done with the compatability set=========");
    print("=====Starting with the unique version index========");
    db.adminCommand("listDatabases").databases.forEach(function(d){
    let mdb = db.getSiblingDB(d.name);
    print("======Acting on the db=============", d.name);

    mdb.getCollectionInfos( { type: "collection" } ).forEach(function(c){
      let currentCollection = mdb.getCollection(c.name);

      currentCollection.getIndexes().forEach(function(idx){
         if (idx.unique){
            print("Dropping and recreating the following index:" + tojson(idx))

            assert.commandWorked(mdb.runCommand({dropIndexes: c.name, index: idx.name}));

            let res = mdb.runCommand({ createIndexes: c.name, indexes: [idx] });
            if (res.ok !== 1)
               assert.commandWorked(res);
         }
        });
      });
    });
    print("========Completed with the unique version index==========");
    print("====Starting with the removing the wildcard indexes=====");
    db.adminCommand("listDatabases").databases.forEach(function(d){
    let mdb = db.getSiblingDB(d.name);
    mdb.getCollectionInfos({ type: "collection" }).forEach(function(c){
    let currentCollection = mdb.getCollection(c.name);
    currentCollection.getIndexes().forEach(function(idx){

         var key = Object.keys(idx.key);
         if (key[0].includes("$**")) {

           print("Dropping index: " + idx.name + " from " + idx.ns);

           let res = mdb.runCommand({dropIndexes: currentCollection, index: idx.name});
           assert.commandWorked(res);

         }

      });
     });
    });

    print("=========Completed with removing the wildcard indexes========");
kind: ConfigMap
metadata:
  name: migrationcommands
  namespace: ${NAMESPACE}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: mongodb
    release: mongodb
  name: mongodb
  namespace: ${NAMESPACE}
spec:
  ports:
  - name: mongodb
    port: 27017
    targetPort: mongodb
  selector:
    app: mongodb
    release: mongodb
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: mongodb
    release: mongodb
  name: mongodb
  namespace: ${NAMESPACE}
spec:
  selector:
    matchLabels:
      app: mongodb
      release: mongodb
  template:
    metadata:
      labels:
        app: mongodb
        chart: mongodb-7.2.7
        release: mongodb
    spec:
      containers:
      - env:
        - name: MONGODB_SYSTEM_LOG_VERBOSITY
          value: "0"
        - name: MONGODB_DISABLE_SYSTEM_LOG
          value: "no"
        - name: MONGODB_ENABLE_IPV6
          value: "no"
        - name: MONGODB_ENABLE_DIRECTORY_PER_DB
          value: "no"
        image: docker.io/bitnami/mongodb:4.0.12-debian-9-r22
        imagePullPolicy: IfNotPresent
        livenessProbe:
          exec:
            command:
            - mongo
            - --eval
            - db.adminCommand('ping')
          failureThreshold: 6
          initialDelaySeconds: 30
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 5
        name: mongodb
        ports:
        - containerPort: 27017
          name: mongodb
        readinessProbe:
          exec:
            command:
            - mongo
            - --eval
            - db.adminCommand('ping')
          failureThreshold: 6
          initialDelaySeconds: 5
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 5
        resources:
          limits:
            cpu: 500m
            memory: 2500Mi
          requests:
            cpu: 250m
            memory: 2Gi
        securityContext:
          runAsNonRoot: true
          runAsUser: 1001
        volumeMounts:
        - mountPath: /bitnami/mongodb/data/db
          name: data
          subPath: mongodb
      imagePullSecrets:
      - name: ${IMAGE_PULL_SECRETS}
      initContainers:
      - command:
        - chown
        - -R
        - 1001:1001
        - /bitnami/mongodb/data/db
        image: docker.io/bitnami/minideb:stretch
        imagePullPolicy: Always
        name: volume-permissions
        resources: {}
        securityContext:
          runAsUser: 0
        volumeMounts:
        - mountPath: /bitnami/mongodb/data/db
          name: data
          subPath: mongodb
      - args:
        - ls -lart /data/db;if [  -n "$(ls -A /data/db 2> /dev/null)" ] && [ ! -f
          /data/db/upgrade.done ]; then mongod & sleep 15;mongo /usr/local/entrypoint.js;sleep
          10;mongod --shutdown; sleep 10;touch /data/db/upgrade.done;fi
        command:
        - /bin/sh
        - -c
        image: gcr.io/snps-swip-staging/swip_mongodb:0.0.6
        name: mongomigration
        volumeMounts:
        - mountPath: /usr/local/entrypoint.js
          name: configmapvolume
          readOnly: true
          subPath: entrypoint.js
        - mountPath: /data/db
          name: data
          subPath: mongodb
      securityContext:
        fsGroup: 1001
      volumes:
      - configMap:
          defaultMode: 448
          name: migrationcommands
        name: configmapvolume
      - name: data
        persistentVolumeClaim:
          claimName: mongodb
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  labels:
    app: mongodb
    environment: ${ENVIRONMENT_NAME}
    release: mongodb
  name: mongodb
  namespace: ${NAMESPACE}
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: ${MONGODB_PV_SIZE}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app: upload-minio
    environment: ${ENVIRONMENT_NAME}
  name: upload-minio
  namespace: ${NAMESPACE}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: upload-minio
    environment: ${ENVIRONMENT_NAME}
    service: upload-server
  name: upload-server
  namespace: ${NAMESPACE}
spec:
  ports:
  - name: service
    port: 9000
    protocol: TCP
    targetPort: 9000
  selector:
    app: upload-minio
    environment: ${ENVIRONMENT_NAME}
    release: minio
  type: ClusterIP
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  labels:
    app: upload-minio
    environment: ${ENVIRONMENT_NAME}
    service: upload-server
  name: upload-minio
  namespace: ${NAMESPACE}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: upload-minio
      environment: ${ENVIRONMENT_NAME}
      release: minio
  strategy:
    type: Recreate
  template:
    metadata:
      annotations:
        checksum/config: 93e898cd531bb5586c5f150eff38c939a48e0b68a0929a6d8aacd7a7f9def5d3
        checksum/secrets: 01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b
        cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
      labels:
        app: upload-minio
        environment: ${ENVIRONMENT_NAME}
        release: minio
      name: minio
    spec:
      containers:
      - command:
        - /bin/sh
        - -ce
        - /usr/bin/docker-entrypoint.sh minio -C /data/ server /opt/data
        env:
        - name: MINIO_ACCESS_KEY
          valueFrom:
            secretKeyRef:
              key: access_key
              name: swip-tools-minio
        - name: MINIO_SECRET_KEY
          valueFrom:
            secretKeyRef:
              key: secret_key
              name: swip-tools-minio
        - name: MINIO_PROMETHEUS_AUTH_TYPE
          value: public
        - name: MINIO_BROWSER
          value: "off"
        image: minio/minio:RELEASE.2019-10-12T01-39-57Z
        imagePullPolicy: IfNotPresent
        livenessProbe:
          failureThreshold: 3
          httpGet:
            path: /minio/health/live
            port: service
            scheme: HTTP
          initialDelaySeconds: 5
          periodSeconds: 30
          successThreshold: 1
          timeoutSeconds: 1
        name: minio
        ports:
        - containerPort: 9000
          name: service
        readinessProbe:
          failureThreshold: 3
          httpGet:
            path: /minio/health/ready
            port: service
          initialDelaySeconds: 5
          periodSeconds: 15
          successThreshold: 1
          timeoutSeconds: 1
        resources:
          limits:
            cpu: 500m
            memory: 1024Mi
          requests:
            cpu: 250m
            memory: 256Mi
        volumeMounts:
        - mountPath: /opt/data
          name: upload-minio
        - mountPath: /data/
          name: minio-config-dir
      initContainers:
      - command:
        - sh
        - -c
        - mkdir -p /opt/data/${NAMESPACE}-uploads-bucket
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        image: docker.io/busybox:1
        name: bootstrap-upload-server
        volumeMounts:
        - mountPath: /opt/data
          name: upload-minio
          readOnly: false
      serviceAccountName: upload-minio
      volumes:
      - name: upload-minio
        persistentVolumeClaim:
          claimName: upload-minio-pv-claim
      - emptyDir: {}
        name: minio-config-dir
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  environment: ${ENVIRONMENT_NAME}
  labels:
    app: upload-minio
    environment: ${ENVIRONMENT_NAME}
  name: upload-minio-pv-claim
  namespace: ${NAMESPACE}
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: ${UPLOAD_SERVER_PV_SIZE}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app: download-minio
    environment: ${ENVIRONMENT_NAME}
  name: download-minio
  namespace: ${NAMESPACE}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: download-minio
    environment: ${ENVIRONMENT_NAME}
    service: download-server
  name: download-server
  namespace: ${NAMESPACE}
spec:
  ports:
  - name: service
    port: 9000
    protocol: TCP
    targetPort: 9000
  selector:
    app: download-minio
    environment: ${ENVIRONMENT_NAME}
    release: minio
  type: ClusterIP
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  labels:
    app: download-minio
    environment: ${ENVIRONMENT_NAME}
    service: download-server
  name: download-minio
  namespace: ${NAMESPACE}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: download-minio
      environment: ${ENVIRONMENT_NAME}
      release: minio
  strategy:
    type: Recreate
  template:
    metadata:
      annotations:
        checksum/config: 93e898cd531bb5586c5f150eff38c939a48e0b68a0929a6d8aacd7a7f9def5d3
        checksum/secrets: 01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b
        cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
      labels:
        app: download-minio
        environment: ${ENVIRONMENT_NAME}
        release: minio
      name: minio
    spec:
      containers:
      - command:
        - /bin/sh
        - -ce
        - /usr/bin/docker-entrypoint.sh minio -C /data/ server /opt/data
        env:
        - name: MINIO_ACCESS_KEY
          valueFrom:
            secretKeyRef:
              key: access_key
              name: swip-tools-minio
        - name: MINIO_SECRET_KEY
          valueFrom:
            secretKeyRef:
              key: secret_key
              name: swip-tools-minio
        - name: GOOGLE_APPLICATION_CREDENTIALS
          value: /etc/credentials/gcs_key.json
        - name: MINIO_BROWSER
          value: "off"
        image: minio/minio:RELEASE.2019-10-12T01-39-57Z
        imagePullPolicy: IfNotPresent
        name: minio
        ports:
        - containerPort: 9000
          name: service
        readinessProbe:
          failureThreshold: 3
          httpGet:
            path: /minio/health/ready
            port: service
          initialDelaySeconds: 5
          periodSeconds: 15
          successThreshold: 1
          timeoutSeconds: 1
        resources:
          limits:
            cpu: 500m
            memory: 1024Mi
          requests:
            cpu: 250m
            memory: 256Mi
        volumeMounts:
        - mountPath: /opt/data
          name: download-minio
          readOnly: false
        - mountPath: /data/
          name: minio-config-dir
      initContainers:
      - command:
        - sh
        - -c
        - mkdir -p /opt/data/tools-store-${ENVIRONMENT_NAME}
        env:
        - name: ENVIRONMENT_NAME
          value: ${ENVIRONMENT_NAME}
        image: docker.io/busybox:1
        name: bootstrap-download-server
        volumeMounts:
        - mountPath: /opt/data
          name: download-minio
          readOnly: false
      serviceAccountName: download-minio
      volumes:
      - name: minio-user
        secret:
          secretName: swip-tools-minio
      - name: download-minio
        persistentVolumeClaim:
          claimName: download-minio-pv-claim
      - emptyDir: {}
        name: minio-config-dir
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  environment: ${ENVIRONMENT_NAME}
  labels:
    app: download-minio
    environment: ${ENVIRONMENT_NAME}
  name: download-minio-pv-claim
  namespace: ${NAMESPACE}
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: ${DOWNLOAD_SERVER_PV_SIZE}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app: init-vault
    release: vault
  name: init-vault
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app: vault
    release: vault
  name: vault
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app: init-vault
    release: vault
  name: init-vault
rules:
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app: init-vault
    release: vault
  name: init-vault
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: init-vault
subjects:
- kind: ServiceAccount
  name: init-vault
---
apiVersion: v1
data:
  config.json: |
    {"listener":{"tcp":{"address":"[::]:8200","cluster_address":"[::]:8201","tls_cert_file":"/vault/tls/tls.crt","tls_cipher_suites":"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_256_GCM_SHA384,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA","tls_disable":false,"tls_key_file":"/vault/tls/tls.key","tls_prefer_server_cipher_suites":true}},"storage":{"postgresql":{}},"ui":false}
kind: ConfigMap
metadata:
  labels:
    app: vault
    release: vault
  name: vault-config
---
apiVersion: v1
data:
  auth-client.hcl: |-
    path "secret/data/auth/public/*" {
      capabilities = ["list", "read"]
    }

    path "secret/metadata/auth/public/*" {
      capabilities = ["list", "read"]
    }

    path "secret/data/migratorLog" {
      capabilities = ["list", "read"]
    }

    path "secret/data/migratorLog" {
      capabilities = ["list", "read"]
    }
  auth-server.hcl: |-
    path "secret/data/auth/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }

    path "secret/metadata/auth/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }

    path "secret/destroy/auth/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }

    path "secret/delete/auth/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }

    path "secret/undelete/auth/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }

    path "secret/data/migratorLog" {
      capabilities = ["list", "read"]
    }
  tds-code-analysis.hcl: |-
    path "secret/data/auth/public/*" {
      capabilities = ["list", "read"]
    }

    path "secret/metadata/auth/public/*" {
      capabilities = ["list", "read"]
    }

    path "secret/data/migratorLog" {
      capabilities = ["list", "read"]
    }

    path "secret/data/codeanalysis/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }
  vault-migrator.hcl: |
    path "secret/metadata/*" {
      capabilities = ["create", "read", "update", "list"]
    }

    path "secret/data/*" {
      capabilities = ["create", "read", "update", "list"]
    }
kind: ConfigMap
metadata:
  name: vault-policies-new
---
apiVersion: v1
data:
  database: vault
  host: ${POSTGRES_HOST}
  port: ${POSTGRES_PORT}
  sslmode: disable
kind: ConfigMap
metadata:
  name: vault-postgresql
---
apiVersion: v1
data:
  bootstrap-vault.sh: |-
    #!/bin/bash

    source /opt/scripts/vault-operations.sh

    check_vault_service_status

    set -euo pipefail
    export VAULT_TOKEN=$POLARIS_VAULT_TOKEN
    export K8S_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    export K8S_API_SERVER=https://kubernetes.default
    login_to_vault
    is_vault_ro_secret_exist=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-only --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
    is_vault_rwauth_secret_exist=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-write-auth --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
    is_vault_rwtds_secret_exist=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-write-tds --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
    is_vault_migrator_secret_exist=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-migrator --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
    if [[ $is_vault_ro_secret_exist -ne 200 || \
      $is_vault_rwauth_secret_exist -ne 200 || \
      $is_vault_rwtds_secret_exist -ne 200 || \
      $is_vault_migrator_secret_exist -ne 200 ]];then
      enable_secrets_engine_in_vault
      create_or_update_vault_policies
      enable_pki_engine_in_vault
      tune_pki_secret_engine
      enable_cert_based_authentication_in_vault
      generate_vault_read_only_certificate_for_polaris
      generate_vault_read_write_auth_certificate_for_polaris
      generate_vault_read_write_tds_certificate_for_polaris
      generate_vault_migrator_certificate_for_polaris
    else
      echo "Vault credentials are already exist.. Skipping creation.."
    fi
  migrate.sh: |-
    #!/bin/bash

    export VAULT_FORMAT=json

    wait_for_vault_setup_to_be_ready(){
      while true;do
        status_code1=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-only --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
        status_code2=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-write-auth --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
        status_code3=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-write-tds --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
        status_code4=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-migrator --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
        if [[ $status_code1 -eq 200 && $status_code2 -eq 200 && $status_code3 -eq 200 && $status_code4 -eq 200 ]];then
          echo "Vault setup is ready.."
          break
        else
          echo "Vault setup is not ready.. sleeping for 5s.."
          sleep 5
        fi
      done
    }

    wait_for_auth_service_to_be_ready(){
      while true;do
        curl http://auth-server/healthcheck -s | jq . > /tmp/auth.json
        if [[ $(cat /tmp/auth.json | jq -r -j '.EventStoreLiveness.healthy') && \
          $(cat /tmp/auth.json | jq -r -j '.EventStoreReadiness.healthy') && \
          $(cat /tmp/auth.json | jq -r -j '.MongoHealthCheck.healthy') && \
          $(cat /tmp/auth.json | jq -r -j '.VaultReadiness.healthy') && \
          $(cat /tmp/auth.json | jq -r -j '.deadlocks.healthy') ]];then
          cat /tmp/auth.json
          echo "Auth-server is healthy.. Proceeding for Migration.."
          break
        else
          echo "Auth-server is not healthy.. Sleeping for 5s.."
          echo "Statistics :"
          cat /tmp/auth.json
          sleep 5
        fi
      done
    }

    login_to_src_vault(){
      export VAULT_ADDR=$SRC_VAULT_ADDR
      export VAULT_TOKEN=$SRC_VAULT_TOKEN
      export VAULT_CACERT=$SRC_VAULT_CACERT
      vault login -no-store $VAULT_TOKEN > /dev/null
    }

    login_to_dst_vault(){
      export VAULT_ADDR=$DST_VAULT_ADDR
      export VAULT_TOKEN=$DST_VAULT_TOKEN
      export VAULT_CACERT=$DST_VAULT_CACERT
      vault login -no-store $VAULT_TOKEN > /dev/null
    }

    update_secret(){
      echo "Migrating secret : $1"
      vault kv get -tls-skip-verify $1 | jq '.data.data' > /tmp/secret.json
      login_to_dst_vault
      vault kv put $1 @/tmp/secret.json > /dev/null
      login_to_src_vault
    }

    check_for_vault_availability(){
      while true; do
        vault status -format=json > /tmp/status.json
        if [ $? -eq 1 ]; then
          echo "Vault service is unreachable.. sleeping for 30s.."
          sleep 30
        else
          if $(cat /tmp/status.json | jq -r -j '.initialized');then
            if $(cat /tmp/status.json | jq -r -j '.sealed');then
              echo "Vault is sealed.. Waiting for it to be unsealed.."
              sleep 2
            else
              echo "Vault service is available and accepting connections.."
              break
            fi
          else
            echo "Vault is not initialized.. Waiting for it to be initialized.."
            sleep 2
          fi
        fi
      done
    }

    recursive(){
      login_to_src_vault
      name=$1
      for entry in $(vault kv list -tls-skip-verify $name | jq -c -r '.[]');do
        if [[ $entry = *?[/] ]];then
          recursive $name$entry &
          wait
        else
          update_secret $name$entry
        fi
      done
    }

    export K8S_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    export K8S_API_SERVER=https://kubernetes.default

    if [[ $(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-migration-status --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null) -eq 200 ]];then
      echo "Migration is already ran.. Skipping.."
    else
      wait_for_vault_setup_to_be_ready
      echo "Checking for source vault availability.."
      export VAULT_ADDR=$SRC_VAULT_ADDR
      export VAULT_CACERT=$SRC_VAULT_CACERT
      check_for_vault_availability
      echo "Checking for destination vault availability.."
      export VAULT_ADDR=$DST_VAULT_ADDR
      export VAULT_CACERT=$DST_VAULT_CACERT
      check_for_vault_availability
      recursive "secret/"
      curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X POST -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null -d @- <<EOF
        {"metadata": {"name":"vault-migration-status"},"data":{"status":"done"}}
    EOF
    fi
  renew-certs.sh: |-
    #!/bin/bash

    check_for_expiry_and_renew_it(){
      curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-only --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --silent | jq -r '.data."tls.crt"' | base64 -d > /tmp/tls.crt
      openssl x509 -enddate -noout -in /tmp/tls.crt
      if openssl x509 -checkend 259200 -noout -in /tmp/tls.crt;then
        echo "Certificate is good.."
      else
        echo "Certificate is about to expire in 3 days.. Renewing certs.."
        login_to_vault
        tune_pki_secret_engine
        enable_cert_based_authentication_in_vault
        generate_vault_read_only_certificate_for_polaris
        generate_vault_read_write_auth_certificate_for_polaris
        generate_vault_read_write_tds_certificate_for_polaris
        generate_vault_migrator_certificate_for_polaris
      fi
    }

    source /opt/scripts/vault-operations.sh

    check_vault_service_status

    set -euo pipefail

    export VAULT_TOKEN=$POLARIS_VAULT_TOKEN
    export K8S_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    export K8S_API_SERVER=https://kubernetes.default

    is_vault_ro_secret_exist=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-only --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
    is_vault_rwauth_secret_exist=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-write-auth --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
    is_vault_rwtds_secret_exist=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-write-tds --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
    is_vault_migrator_secret_exist=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-migrator --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)

    if [[ $is_vault_ro_secret_exist -ne 200 || \
      $is_vault_rwauth_secret_exist -ne 200 || \
      $is_vault_rwtds_secret_exist -ne 200 || \
      $is_vault_migrator_secret_exist -ne 200 ]];then
      echo "Vault credentials doesn't exist.. Skipping expiry checking.."
    else
      check_for_expiry_and_renew_it
    fi
  vault-init.sh: "#!/bin/bash\n\ninit_vault(){\n  vault operator init -key-shares=1
    -key-threshold=1 -format=json > /tmp/keys.json\n  export UNSEAL_KEY=$(cat /tmp/keys.json
    | jq -r -j '.unseal_keys_b64[0]' | base64 )\n  export ROOT_TOKEN=$(cat /tmp/keys.json
    | jq -r -j '.root_token' | base64 )\n  export K8S_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\n
    \ export K8S_API_SERVER=https://kubernetes.default\n  cat <<EOF > /tmp/payload.json\n
    \   {\n      \"metadata\":{\n        \"name\":\"vault-tokens\"\n      },\n      \"data\":{\n
    \       \"root_token\":\"$ROOT_TOKEN\",\n        \"unseal_key\":\"$UNSEAL_KEY\"\n
    \     }\n    }\nEOF\n\n  curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets
    \\\n    --write-out '%{http_code}' --silent --output /dev/null \\\n    --header
    \"Authorization: Bearer $K8S_TOKEN\" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    \\\n    -X POST -H \"Content-Type: application/json\" \\\n    --data @/tmp/payload.json\n\n
    \ curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-tokens \\\n
    \   --write-out '%{http_code}' --silent --output /dev/null \\\n    --header \"Authorization:
    Bearer $K8S_TOKEN\" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    \\\n    -X PUT -H \"Content-Type: application/json\" \\\n    --data @/tmp/payload.json\n
    \ \n}\n\nwhile true; do\n  vault status -format=json > /tmp/status.json\n  if
    [ $? -eq 1 ]; then\n    echo \"Vault service is unreachable.. sleeping for 2s..\"\n
    \   sleep 2\n  else\n    VAULT_INIT_STATUS=$(cat /tmp/status.json | jq -r '.initialized')\n
    \   VAULT_SEAL_STATUS=$(cat /tmp/status.json | jq -r '.sealed')\n    if [ \"$VAULT_INIT_STATUS\"
    == \"false\" ];then\n      echo \"Initializing vault..\"\n      init_vault\n    else\n
    \     sleep 300\n    fi\n  fi\ndone"
  vault-operations.sh: |-
    #!/bin/bash

    check_vault_service_status(){
      echo "Checking for vault service availability.."
      while true; do
        vault status -format=json > /tmp/status.json
        if [ $? -eq 1 ]; then
          echo "Vault service is unreachable.. sleeping for 5s.."
          sleep 5
        else
          VAULT_INIT_STATUS=$(cat /tmp/status.json | jq -r '.initialized')
          VAULT_SEAL_STATUS=$(cat /tmp/status.json | jq -r '.sealed')
          if [ "$VAULT_INIT_STATUS" == "true" ];then
            if [ "$VAULT_SEAL_STATUS" == "false" ];then
              echo "Vault initialize status : $VAULT_INIT_STATUS"
              echo "Vault seal status : $VAULT_SEAL_STATUS"
              echo "Vault service is available and accepting connections.."
              break
            fi
          fi
        fi
      done
    }

    login_to_vault(){
      echo "Trying to login into Vault.."
      vault login -no-store $VAULT_TOKEN > /dev/null
    }

    enable_secrets_engine_in_vault(){
      if [ -z $(vault secrets list -format=json | jq "keys" | jq '.[] | select(. == "secret/")') ]; then
        echo "Enabling secret engine of type 'kv' with version '2' under 'secret' path.."
        vault secrets enable -path=secret -version=2 kv
      fi
    }

    create_or_update_vault_policies(){
      echo "Creating/Updating auth-server policy.."
      vault policy write auth-server /opt/policies/auth-server.hcl
      echo "Creating auth-client policy.."
      vault policy write auth-client /opt/policies/auth-client.hcl
      echo "Creating tds-code-analysis policy.."
      vault policy write tds-code-analysis /opt/policies/tds-code-analysis.hcl
      echo "Creating vault-migrator policy.."
        vault policy write vault-migrator /opt/policies/vault-migrator.hcl
    }

    enable_pki_engine_in_vault(){
      if [ -z $(vault secrets list -format=json | jq "keys" | jq '.[] | select(. == "pki/")') ]; then
        echo "Enabling pki engine at 'pki' path.."
        vault secrets enable pki
      fi
    }

    # Tune secret engine to generate certificates valid for 1 year
    tune_pki_secret_engine(){
      echo "Tuning pki secret engine.."
      vault secrets tune -max-lease-ttl=87600h pki
      echo "Generating self-signed root CA certificate"
      vault write -force pki/root/generate/internal common_name=vault ttl=87600h private_key_format="pkcs8"
      echo "Generating URL configurations to include them in certificates.."
      vault write -force pki/config/urls issuing_certificates="${VAULT_ADDR}/v1/pki/ca" crl_distribution_points="${VAULT_ADDR}/v1/pki/crl"
      echo "Generating pki roles.."
      vault write -force pki/roles/client \
        allow_any_name="true" \
        client_flag="true" \
        max_ttl="87600h" \
        server_flag="false"
      vault write -force pki/roles/server \
        allow_any_name="true" \
        allowed_domains="cluster.local" \
        allow_subdomains="true" \
        client_flag="true" \
        max_ttl="87600h" \
        enforce_hostnames="false" \
        server_flag="true"
    }

    enable_cert_based_authentication_in_vault(){
      if [ -z $(vault auth list -format=json | jq "keys" | jq '.[] | select(. == "cert/")') ]; then
        echo "Enabling cert based authentication for vault.."
        vault auth enable cert
      fi
    }

    generate_vault_read_only_certificate_for_polaris(){
      echo "Generating certs for auth-client.."
      vault write -force pki/issue/client common_name=auth-client.$NAMESPACE.svc.cluster.local alt_names="auth-client.$NAMESPACE.svc.cluster.local,auth-client,localhost" ip_sans="127.0.0.1" -format=json ttl=336h private_key_format="pkcs8" > /tmp/auth-client-certificates.json
      echo "Extracting certs from auth-client-certificates.json.."
      cat /tmp/auth-client-certificates.json | jq -r '.data.certificate' > /tmp/tls.crt
      cat /tmp/auth-client-certificates.json | jq -r '.data.private_key' > /tmp/tls.key
      cat /tmp/auth-client-certificates.json | jq -r '.data.issuing_ca' > /tmp/ca.crt
      echo "Uploading certificate into vault.."
      vault write -force auth/cert/certs/vault-read-only \
        display_name=vault-read-only \
        policies=auth-client \
        certificate=@/tmp/tls.crt
      echo "Creating vault-read-only kubernetes secret.."
      export CA_CRT=$(cat /tmp/ca.crt | base64) TLS_CRT=$(cat /tmp/tls.crt | base64 ) TLS_KEY=$(cat /tmp/tls.key | base64)
      status_code=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-only --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
      if [[ $status_code -ne 200 ]];then
        curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X POST -H "Content-Type: application/json" -H "Accept: application/json" --write-out '%{http_code}' --silent --output /dev/null -d @- <<EOF
        {"metadata": {"name":"vault-read-only"},"data":{"ca.crt":"$CA_CRT","tls.crt":"$TLS_CRT","tls.key":"$TLS_KEY"}}
    EOF
      else
        curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-only --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X PUT -H "Content-Type: application/json" -H "Accept: application/json" --write-out '%{http_code}' --silent --output /dev/null -d @- <<EOF
        {"metadata": {"name":"vault-read-only"},"data":{"ca.crt":"$CA_CRT","tls.crt":"$TLS_CRT","tls.key":"$TLS_KEY"}}
    EOF
      fi
    }

    generate_vault_read_write_auth_certificate_for_polaris(){
      echo "Generating certs for auth-server.."
      vault write -force pki/issue/server common_name=auth-server.$NAMESPACE.svc.cluster.local alt_names="auth-server.$NAMESPACE.svc.cluster.local,auth-server,localhost" ip_sans="127.0.0.1" -format=json ttl=336h private_key_format="pkcs8" > /tmp/auth-server-certificates.json
      echo "Extracting certs from auth-server-certificates.json.."
      cat /tmp/auth-server-certificates.json | jq -r '.data.certificate' > /tmp/tls.crt
      cat /tmp/auth-server-certificates.json | jq -r '.data.private_key' > /tmp/tls.key
      cat /tmp/auth-server-certificates.json | jq -r '.data.issuing_ca' > /tmp/ca.crt
      echo "Uploading certificate into vault.."
      vault write -force auth/cert/certs/vault-read-write-auth \
          display_name=vault-read-write \
          policies=auth-server \
          certificate=@/tmp/tls.crt
      echo "Creating vault-read-write-auth kubernetes secret.."
      export CA_CRT=$(cat /tmp/ca.crt | base64) TLS_CRT=$(cat /tmp/tls.crt | base64 ) TLS_KEY=$(cat /tmp/tls.key | base64)
      status_code=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-write-auth --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
      if [[ $status_code -ne 200 ]];then
        curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X POST -H "Content-Type: application/json" -H "Accept: application/json" --write-out '%{http_code}' --silent --output /dev/null -d @- <<EOF
        {"metadata": {"name":"vault-read-write-auth"},"data":{"ca.crt":"$CA_CRT","tls.crt":"$TLS_CRT","tls.key":"$TLS_KEY"}}
    EOF
      else
        curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-write-auth --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X PUT -H "Content-Type: application/json" -H "Accept: application/json" --write-out '%{http_code}' --silent --output /dev/null -d @- <<EOF
        {"metadata": {"name":"vault-read-write-auth"},"data":{"ca.crt":"$CA_CRT","tls.crt":"$TLS_CRT","tls.key":"$TLS_KEY"}}
    EOF
      fi
    }

    generate_vault_read_write_tds_certificate_for_polaris(){
      echo "Generating certs for tds-code-analysis.."
      vault write -force pki/issue/server common_name=tds-code-analysis.$NAMESPACE.svc.cluster.local alt_names="tds-code-analysis.$NAMESPACE.svc.cluster.local,tds-code-analysis,localhost" ip_sans="127.0.0.1" -format=json ttl=336h private_key_format="pkcs8" > /tmp/tds-code-analysis-certificates.json
      echo "Extracting certs from tds-code-analysis-certificates.json.."
      cat /tmp/tds-code-analysis-certificates.json | jq -r '.data.certificate' > /tmp/tls.crt
      cat /tmp/tds-code-analysis-certificates.json | jq -r '.data.private_key' > /tmp/tls.key
      cat /tmp/tds-code-analysis-certificates.json | jq -r '.data.issuing_ca' > /tmp/ca.crt
      echo "Uploading certificate into vault.."
      vault write -force auth/cert/certs/vault-read-write-tds \
          display_name=vault-read-write-tds \
          policies=tds-code-analysis \
          certificate=@/tmp/tls.crt
      echo "Creating vault-read-write-tds kubernetes secret.."
      export CA_CRT=$(cat /tmp/ca.crt | base64) TLS_CRT=$(cat /tmp/tls.crt | base64 ) TLS_KEY=$(cat /tmp/tls.key | base64)
      status_code=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-write-tds --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
      if [[ $status_code -ne 200 ]];then
        curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X POST -H "Content-Type: application/json" -H "Accept: application/json" --write-out '%{http_code}' --silent --output /dev/null -d @- <<EOF
        {"metadata": {"name":"vault-read-write-tds"},"data":{"ca.crt":"$CA_CRT","tls.crt":"$TLS_CRT","tls.key":"$TLS_KEY"}}
    EOF
      else
        curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-read-write-tds --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X PUT -H "Content-Type: application/json" -H "Accept: application/json" --write-out '%{http_code}' --silent --output /dev/null -d @- <<EOF
        {"metadata": {"name":"vault-read-write-tds"},"data":{"ca.crt":"$CA_CRT","tls.crt":"$TLS_CRT","tls.key":"$TLS_KEY"}}
    EOF
      fi
    }

    generate_vault_migrator_certificate_for_polaris(){
      echo "Generating certs for vault-migrator.."
      vault write -force pki/issue/server common_name=vault-migrator.$NAMESPACE.svc.cluster.local alt_names="vault-migrator.$NAMESPACE.svc.cluster.local,vault-migrator,localhost" ip_sans="127.0.0.1" -format=json ttl=336h private_key_format="pkcs8" > /tmp/vault-migrator-certificates.json
      echo "Extracting certs from tds-code-analysis-certificates.json.."
      cat /tmp/vault-migrator-certificates.json | jq -r '.data.certificate' > /tmp/tls.crt
      cat /tmp/vault-migrator-certificates.json | jq -r '.data.private_key' > /tmp/tls.key
      cat /tmp/vault-migrator-certificates.json | jq -r '.data.issuing_ca' > /tmp/ca.crt
      echo "Uploading certificate into vault.."
      vault write -force auth/cert/certs/vault-migrator \
          display_name=vault-migrator \
          policies=vault-migrator \
          certificate=@/tmp/tls.crt
      echo "Creating vault-migrator kubernetes secret.."
      export CA_CRT=$(cat /tmp/ca.crt | base64) TLS_CRT=$(cat /tmp/tls.crt | base64 ) TLS_KEY=$(cat /tmp/tls.key | base64)
      status_code=$(curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-migrator --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" --write-out '%{http_code}' --silent --output /dev/null)
      if [[ $status_code -ne 200 ]];then
        curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X POST -H "Content-Type: application/json" -H "Accept: application/json" --write-out '%{http_code}' --silent --output /dev/null -d @- <<EOF
        {"metadata": {"name":"vault-migrator"},"data":{"ca.crt":"$CA_CRT","tls.crt":"$TLS_CRT","tls.key":"$TLS_KEY"}}
    EOF
      else
        curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-migrator --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X PUT -H "Content-Type: application/json" -H "Accept: application/json" --write-out '%{http_code}' --silent --output /dev/null -d @- <<EOF
        {"metadata": {"name":"vault-migrator"},"data":{"ca.crt":"$CA_CRT","tls.crt":"$TLS_CRT","tls.key":"$TLS_KEY"}}
    EOF
      fi
    }
  vault-unseal.sh: |-
    #!/bin/bash

    unseal_vault(){
      export K8S_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
      export K8S_API_SERVER=https://kubernetes.default
      curl -k $K8S_API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/vault-tokens --header "Authorization: Bearer $K8S_TOKEN" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -X GET -H "Content-Type: application/json" > /tmp/keys.json
      vault operator unseal $(cat /tmp/keys.json | jq -r '.data.unseal_key' | base64 -d )
    }

    while true; do
      vault status -format=json > /tmp/status.json
      if [ $? -eq 1 ]; then
        echo "Vault service is unreachable.. sleeping for 2s.."
        sleep 2
      else
        VAULT_INIT_STATUS=$(cat /tmp/status.json | jq -r '.initialized')
        VAULT_SEAL_STATUS=$(cat /tmp/status.json | jq -r '.sealed')
        if [ "$VAULT_INIT_STATUS" == "true" ];then
          if [ "$VAULT_SEAL_STATUS" == "true" ];then
            echo "Unsealing vault.."
            unseal_vault
          else
            sleep 300
          fi
        else
          echo "Vault is not initialized.. Waiting for it to be initialized.."
          sleep 2
        fi
      fi
    done
kind: ConfigMap
metadata:
  name: vault-scripts
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: vault
    release: vault
  name: vault
spec:
  ports:
  - name: api
    port: 8200
    protocol: TCP
    targetPort: 8200
  selector:
    app: vault
    release: vault
  type: ClusterIP
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  labels:
    app: init-vault
    release: vault
  name: init-vault
spec:
  selector:
    matchLabels:
      app: init-vault
  template:
    metadata:
      labels:
        app: init-vault
        release: vault
      name: init-vault
    spec:
      containers:
      - command:
        - /opt/scripts/vault-init.sh
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: VAULT_ADDR
          value: https://vault:8200
        - name: VAULT_CACERT
          value: /vault/tls/ca.crt
        image: gcr.io/snps-swip-staging/polaris-vault-util:latest
        imagePullPolicy: Always
        name: init-vault
        volumeMounts:
        - mountPath: /vault/tls
          name: vault-tls-certificate
        - mountPath: /opt/scripts/vault-init.sh
          name: vault-scripts
          subPath: vault-init.sh
      restartPolicy: Always
      securityContext:
        runAsNonRoot: true
        runAsUser: 5000
      serviceAccount: init-vault
      volumes:
      - name: vault-tls-certificate
        secret:
          secretName: vault-tls-certificate-new
      - configMap:
          defaultMode: 511
          items:
          - key: vault-init.sh
            path: vault-init.sh
          name: vault-scripts
        name: vault-scripts
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  annotations: {}
  labels:
    app: vault
    release: vault
  name: vault
spec:
  replicas: 3
  strategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      annotations:
        checksum/config: 1bbb314d3307362d181aaf9081cebc0d7e66d69ce3aabd8f183fc7b356b19849
        cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
      labels:
        app: vault
        release: vault
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  app: vault
                  release: vault
              topologyKey: kubernetes.io/hostname
            weight: 100
      containers:
      - command:
        - /bin/sh
        - -ec
        - |2

          cat <<EOF > /tmp/storage-config.hcl
          storage "postgresql" {
            connection_url = "postgres://${PGUSER}:${PGPASSWORD}@${PGHOST}:${PGPORT}/${PGDATABASE}?sslmode=${PGSSLMODE}"
            ha_enabled = "true"
            ha_table = "vault_ha_locks"
          }
          EOF

          cat <<EOF > /tmp/telemetry.hcl
          telemetry {
            prometheus_retention_time = "30s"
            disable_hostname = true
            dogstatsd_addr = "${HOST_IP}:8125"
            dogstatsd_tags = ["namespace=${NAMESPACE}","service=polaris-vault"]
          }
          EOF

          exec vault server -config /vault/config/config.json -config /tmp/storage-config.hcl -config /tmp/telemetry.hcl
        env:
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: HOST_IP
          valueFrom:
            fieldRef:
              fieldPath: status.hostIP
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: VAULT_API_ADDR
          value: https://$(POD_IP):8200
        - name: VAULT_CLUSTER_ADDR
          value: https://$(POD_IP):8201
        - name: VAULT_LOG_LEVEL
          value: info
        - name: VAULT_CACERT
          value: /vault/tls/ca.crt
        - name: PGUSER
          valueFrom:
            secretKeyRef:
              key: user
              name: vault-postgresql
        - name: PGPASSWORD
          valueFrom:
            secretKeyRef:
              key: password
              name: vault-postgresql
        - name: PGHOST
          valueFrom:
            configMapKeyRef:
              key: host
              name: vault-postgresql
        - name: PGPORT
          valueFrom:
            configMapKeyRef:
              key: port
              name: vault-postgresql
        - name: PGDATABASE
          valueFrom:
            configMapKeyRef:
              key: database
              name: vault-postgresql
        - name: PGSSLMODE
          valueFrom:
            configMapKeyRef:
              key: sslmode
              name: vault-postgresql
        image: docker.io/vault:1.2.4
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /v1/sys/health?standbyok=true&uninitcode=204&sealedcode=204&
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 30
          periodSeconds: 10
        name: vault
        ports:
        - containerPort: 8200
          name: api
        - containerPort: 8201
          name: cluster-address
        readinessProbe:
          httpGet:
            path: /v1/sys/health?standbycode=204&uninitcode=204&
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 10
          periodSeconds: 10
        resources: {}
        securityContext:
          capabilities:
            add:
            - IPC_LOCK
          readOnlyRootFilesystem: true
        volumeMounts:
        - mountPath: /vault/config/
          name: vault-config
        - mountPath: /root/
          name: vault-root
        - mountPath: /tmp
          name: tmp
        - mountPath: /vault/tls
          name: vault-tls-certificate
      - command:
        - /opt/scripts/vault-unseal.sh
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: VAULT_ADDR
          value: https://localhost:8200
        - name: VAULT_CACERT
          value: /vault/tls/ca.crt
        image: gcr.io/snps-swip-staging/polaris-vault-util:latest
        imagePullPolicy: Always
        name: unseal-vault
        volumeMounts:
        - mountPath: /vault/tls
          name: vault-tls-certificate
        - mountPath: /opt/scripts/vault-unseal.sh
          name: vault-scripts
          subPath: vault-unseal.sh
      - env:
        - name: VAULT_ADDR
          value: https://127.0.0.1:8200
        - name: VAULT_CACERT
          value: /vault/tls/ca.crt
        image: grapeshot/vault_exporter:v0.1.2
        imagePullPolicy: IfNotPresent
        name: vault-exporter
        securityContext:
          readOnlyRootFilesystem: true
        volumeMounts:
        - mountPath: /vault/tls
          name: vault-tls-certificate
      serviceAccountName: init-vault
      volumes:
      - configMap:
          name: vault-config
        name: vault-config
      - emptyDir: {}
        name: vault-root
      - emptyDir: {}
        name: tmp
      - name: vault-secret
        secret:
          optional: true
          secretName: vault
      - name: vault-tls-certificate
        secret:
          secretName: vault-tls-certificate-new
      - configMap:
          defaultMode: 511
          items:
          - key: vault-unseal.sh
            path: vault-unseal.sh
          name: vault-scripts
        name: vault-scripts
---
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: vault-creds-renew
spec:
  jobTemplate:
    spec:
      backoffLimit: 1
      completions: 1
      parallelism: 1
      template:
        spec:
          containers:
          - command:
            - /opt/scripts/renew-certs.sh
            env:
            - name: NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: VAULT_ADDR
              value: https://vault:8200
            - name: VAULT_CACERT
              value: /vault/tls/ca.crt
            - name: POLARIS_VAULT_TOKEN
              valueFrom:
                secretKeyRef:
                  key: root_token
                  name: vault-tokens
            image: gcr.io/snps-swip-staging/polaris-vault-util:latest
            imagePullPolicy: Always
            name: vault-creds-renew
            volumeMounts:
            - mountPath: /vault/tls
              name: vault-tls-certificate-new
            - mountPath: /opt/scripts/renew-certs.sh
              name: vault-scripts
              subPath: renew-certs.sh
            - mountPath: /opt/scripts/vault-operations.sh
              name: vault-scripts
              subPath: vault-operations.sh
          restartPolicy: Never
          securityContext:
            runAsNonRoot: true
            runAsUser: 5000
          serviceAccount: init-vault
          volumes:
          - name: vault-tls-certificate-new
            secret:
              secretName: vault-tls-certificate-new
          - configMap:
              defaultMode: 511
              items:
              - key: renew-certs.sh
                path: renew-certs.sh
              - key: vault-operations.sh
                path: vault-operations.sh
              name: vault-scripts
            name: vault-scripts
  schedule: 0 0 * * *
---
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: vault
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app: vault
      release: vault
---
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-bootstrap
spec:
  backoffLimit: 1
  completions: 1
  parallelism: 1
  template:
    spec:
      containers:
      - command:
        - /opt/scripts/bootstrap-vault.sh
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: VAULT_ADDR
          value: https://vault:8200
        - name: POLARIS_VAULT_TOKEN
          valueFrom:
            secretKeyRef:
              key: root_token
              name: vault-tokens
        - name: VAULT_CACERT
          value: /vault/tls/ca.crt
        image: gcr.io/snps-swip-staging/polaris-vault-util:latest
        imagePullPolicy: Always
        name: init-vault
        volumeMounts:
        - mountPath: /vault/tls
          name: vault-tls-certificate
        - mountPath: /opt/scripts/bootstrap-vault.sh
          name: vault-scripts
          subPath: bootstrap-vault.sh
        - mountPath: /opt/scripts/vault-operations.sh
          name: vault-scripts
          subPath: vault-operations.sh
        - mountPath: /opt/policies
          name: vault-policies
      restartPolicy: Never
      securityContext:
        runAsNonRoot: true
        runAsUser: 5000
      serviceAccount: init-vault
      volumes:
      - name: vault-tls-certificate
        secret:
          secretName: vault-tls-certificate-new
      - configMap:
          defaultMode: 511
          items:
          - key: bootstrap-vault.sh
            path: bootstrap-vault.sh
          - key: vault-operations.sh
            path: vault-operations.sh
          name: vault-scripts
        name: vault-scripts
      - configMap:
          name: vault-policies-new
        name: vault-policies
---
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-migrate
spec:
  backoffLimit: 1
  completions: 1
  parallelism: 1
  template:
    spec:
      containers:
      - command:
        - /opt/scripts/migrate.sh
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: SRC_VAULT_ADDR
          value: https://$(NAMESPACE)-polaris-db-vault:8200
        - name: SRC_VAULT_TOKEN
          valueFrom:
            secretKeyRef:
              key: root_token
              name: vault-init-secret
        - name: DST_VAULT_ADDR
          value: https://vault:8200
        - name: DST_VAULT_TOKEN
          valueFrom:
            secretKeyRef:
              key: root_token
              name: vault-tokens
        - name: SRC_VAULT_CACERT
          value: /vault/old/tls/ca.crt
        - name: DST_VAULT_CACERT
          value: /vault/new/tls/ca.crt
        image: gcr.io/snps-swip-staging/polaris-vault-util:latest
        imagePullPolicy: Always
        name: vault-migrate
        volumeMounts:
        - mountPath: /vault/old/tls
          name: vault-tls-certificate-old
        - mountPath: /vault/new/tls
          name: vault-tls-certificate-new
        - mountPath: /opt/scripts/migrate.sh
          name: vault-scripts
          subPath: migrate.sh
      restartPolicy: Never
      securityContext:
        runAsNonRoot: true
        runAsUser: 5000
      serviceAccount: init-vault
      volumes:
      - name: vault-tls-certificate-new
        secret:
          secretName: vault-tls-certificate-new
      - name: vault-tls-certificate-old
        secret:
          secretName: vault-tls-certificate
      - configMap:
          defaultMode: 511
          items:
          - key: migrate.sh
            path: migrate.sh
          name: vault-scripts
        name: vault-scripts
---
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-postgresql-schema
spec:
  backoffLimit: 4
  template:
    spec:
      containers:
      - command:
        - /bin/sh
        - -ec
        - |
          psql <<EOF

          CREATE TABLE IF NOT EXISTS vault_kv_store (
            parent_path TEXT COLLATE "C" NOT NULL,
            path        TEXT COLLATE "C",
            key         TEXT COLLATE "C",
            value       BYTEA,
            CONSTRAINT pkey PRIMARY KEY (path, key)
          );

          CREATE INDEX IF NOT EXISTS parent_path_idx ON vault_kv_store (parent_path);

          CREATE TABLE IF NOT EXISTS vault_ha_locks (
            ha_key                                      TEXT COLLATE "C" NOT NULL,
            ha_identity                                 TEXT COLLATE "C" NOT NULL,
            ha_value                                    TEXT COLLATE "C",
            valid_until                                 TIMESTAMP WITH TIME ZONE NOT NULL,
            CONSTRAINT ha_key PRIMARY KEY (ha_key)
          );

          EOF
        env:
        - name: PGUSER
          valueFrom:
            secretKeyRef:
              key: user
              name: vault-postgresql
        - name: PGPASSWORD
          valueFrom:
            secretKeyRef:
              key: password
              name: vault-postgresql
        - name: PGDATABASE
          valueFrom:
            configMapKeyRef:
              key: database
              name: vault-postgresql
        - name: PGHOST
          value: postgresql
        - name: PGPORT
          value: "5432"
        - name: PGSSLMODE
          value: disable
        image: postgres:9.6-alpine
        name: vault-postgresql-schema
      restartPolicy: Never
---
apiVersion: v1
data:
  database: vault
  password: ${POSTGRES_PASSWORD}
  sslmode: disable
  user: ${POSTGRES_USERNAME}
kind: secret
metadata:
  name: vault-postgresql
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/instance: eventstore
    app.kubernetes.io/name: eventstore
  name: eventstore-init
  namespace: ${NAMESPACE}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app.kubernetes.io/instance: eventstore
    app.kubernetes.io/name: eventstore
  name: eventstore-init
  namespace: ${NAMESPACE}
rules:
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - create
  - update
  - patch
  - delete
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app.kubernetes.io/instance: eventstore
    app.kubernetes.io/name: eventstore
  name: eventstore-init
  namespace: ${NAMESPACE}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: eventstore-init
subjects:
- kind: ServiceAccount
  name: eventstore-init
  namespace: ${NAMESPACE}
---
apiVersion: v1
data:
  EVENTSTORE_ADD_INTERFACE_PREFIXES: "False"
  EVENTSTORE_CLUSTER_DNS: eventstore
  EVENTSTORE_CLUSTER_GOSSIP_PORT: "2112"
  EVENTSTORE_CLUSTER_SIZE: "3"
  EVENTSTORE_EXT_HTTP_PORT: "2113"
  EVENTSTORE_EXT_HTTP_PREFIXES: http://*:2113/
  EVENTSTORE_EXT_TCP_HEARTBEAT_INTERVAL: "3000"
  EVENTSTORE_EXT_TCP_HEARTBEAT_TIMEOUT: "6000"
  EVENTSTORE_EXT_TCP_PORT: "1113"
  EVENTSTORE_GOSSIP_ALLOWED_DIFFERENCE_MS: "600000"
  EVENTSTORE_GOSSIP_INTERVAL_MS: "2000"
  EVENTSTORE_GOSSIP_ON_SINGLE_NODE: "False"
  EVENTSTORE_GOSSIP_TIMEOUT_MS: "4000"
  EVENTSTORE_INT_HTTP_PORT: "2112"
  EVENTSTORE_INT_HTTP_PREFIXES: http://*:2112/
  EVENTSTORE_INT_TCP_HEARTBEAT_INTERVAL: "1500"
  EVENTSTORE_INT_TCP_HEARTBEAT_TIMEOUT: "3000"
  EVENTSTORE_INT_TCP_PORT: "1112"
  EVENTSTORE_RUN_PROJECTIONS: All
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/component: database
    app.kubernetes.io/instance: eventstore
    app.kubernetes.io/name: eventstore
    helm.sh/chart: eventstore-0.2.5
  name: eventstore-env
  namespace: ${NAMESPACE}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/component: database
    app.kubernetes.io/instance: eventstore
    app.kubernetes.io/name: eventstore
    helm.sh/chart: eventstore-0.2.5
  name: eventstore
  namespace: ${NAMESPACE}
spec:
  clusterIP: None
  ports:
  - name: metrics
    port: 9448
  - name: ext-tcp-port
    port: 1113
    protocol: TCP
    targetPort: 1113
  - name: ext-http-port
    port: 2113
    protocol: TCP
    targetPort: 2113
  selector:
    app.kubernetes.io/instance: eventstore
    app.kubernetes.io/name: eventstore
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app.kubernetes.io/component: database
    app.kubernetes.io/instance: eventstore
    app.kubernetes.io/name: eventstore
    helm.sh/chart: eventstore-0.2.5
  name: eventstore
  namespace: ${NAMESPACE}
spec:
  replicas: 3
  selector:
    matchLabels:
      app.kubernetes.io/instance: eventstore
      app.kubernetes.io/name: eventstore
      component: eventstore
      environment: ${ENVIRONMENT_NAME}
  serviceName: eventstore
  template:
    metadata:
      annotations:
        checksum/config: 984b3227b8f6c9b65af9674e7ef6516c4c91fe9804e0e15a9bff2137ddf4fbc8
      labels:
        app: swip
        app.kubernetes.io/component: database
        app.kubernetes.io/instance: eventstore
        app.kubernetes.io/name: eventstore
        component: eventstore
        environment: ${ENVIRONMENT_NAME}
      name: eventstore
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app.kubernetes.io/component
                operator: In
                values:
                - eventstore
            topologyKey: kubernetes.io/hostname
      containers:
      - env:
        - name: EVENTSTORE_URL
          value: http://127.0.0.1:2113
        - name: CLUSTER_MODE
          value: cluster
        image: marcinbudny/eventstore_exporter:0.5.0
        imagePullPolicy: IfNotPresent
        name: eventstore-exporter
        ports:
        - containerPort: 9448
          name: metrics
          protocol: TCP
      - env:
        - name: EVENTSTORE_INT_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: EVENTSTORE_EXT_IP
          value: 0.0.0.0
        - name: EVENTSTORE_EXT_IP_ADVERTISE_AS
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        envFrom:
        - configMapRef:
            name: eventstore-env
        image: eventstore/eventstore:release-5.0.2
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /stats
            port: 2113
          initialDelaySeconds: 15
          periodSeconds: 15
          timeoutSeconds: 5
        name: eventstore
        ports:
        - containerPort: 1112
        - containerPort: 1113
        - containerPort: 2112
        - containerPort: 2113
        readinessProbe:
          httpGet:
            path: /stats
            port: 2113
          initialDelaySeconds: 15
          periodSeconds: 15
          timeoutSeconds: 5
        resources: {}
        volumeMounts:
        - mountPath: /var/lib/eventstore
          name: data
      nodeSelector: {}
      terminationGracePeriodSeconds: 10
      tolerations: []
      volumes: []
  updateStrategy:
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      labels:
        app: swip
        component: eventstore
        environment: ${ENVIRONMENT_NAME}
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: ${EVENTSTORE_PV_SIZE}
---
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  labels:
    app.kubernetes.io/component: database
    app.kubernetes.io/instance: eventstore
    app.kubernetes.io/name: eventstore
    helm.sh/chart: eventstore-0.2.5
  name: eventstore
  namespace: ${NAMESPACE}
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app.kubernetes.io/instance: eventstore
      app.kubernetes.io/name: eventstore
---
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    app.kubernetes.io/instance: eventstore
    app.kubernetes.io/name: eventstore
  name: eventstore-init
  namespace: ${NAMESPACE}
spec:
  template:
    metadata:
      labels:
        app.kubernetes.io/instance: eventstore
        app.kubernetes.io/name: eventstore
      name: eventstore-init
    spec:
      containers:
      - command:
        - eventstore-init
        env:
        - name: KUBERNETES_LABELS
          value: |-
            environment: "${ENVIRONMENT_NAME}"
            service: "eventstore-init"
        - name: EVENTSTORE_KUBERNETES_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: EVENTSTORE_SECRET_NAME
          value: swip-eventstore-creds
        - name: EVENTSTORE_ADDR
          value: http://eventstore:2113
        image: gcr.io/snps-swip-staging/eventstore-util:latest
        imagePullPolicy: IfNotPresent
        name: eventstore-init
      imagePullSecrets:
      - name: ${IMAGE_PULL_SECRETS}
      initContainers:
      - args:
        - --http-readiness-check-urls=http://eventstore.$(POD_NAMESPACE).svc.cluster.local:2113/stats
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        image: gcr.io/snps-swip-staging/polaris-init:1.0.0
        imagePullPolicy: IfNotPresent
        name: polaris-init
      restartPolicy: OnFailure
      serviceAccount: eventstore-init
